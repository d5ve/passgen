#!/usr/bin/perl

use strict;
use warnings;

=head1 NAME

passgen - generate secure-ish passwords

=head1 SYNOPSIS

    passgen [options]

        Options:
            --words=    Number of words in each passphrase. Default 3.
            --min=      Minimum length of words in passphrase. Default 4.
            --max=      Maximum length of words in passphrase. Default 6.
            --gen=      Number of passphrases to generate. Default 20.
             
    Examples:

        # Default three-word passphrase.
        $ passgen

        # Stronger five-word passphrase with longer words.
        $ passgen --words 5 --min 4 --max 8

=head1 INSTALLATION

    # Install non-core perl dependencies.
    $ cpanm Crypt::Random List::MoreUtils
    # Clone from github
    $ git clone https://github.com/d5ve/passgen.git
    # Run.
    $ passgen/passgen --words 5 --min 4 --max 8

=head1 DESCRIPTION

This perl script generates passwords/passphrases from my chosen template. This
template is for three or more short words to be concatenated together. The
first word is all lowercase, the second word is ALL UPPERCASE, and the third
word uses the standard 'replace vowels with numbers' leetspeek transform. Any
further words continue the pattern starting at step 1 again.

For example:

    hairedBROACHn33d1ng              haired  broach  needing
    tornSTUDIOh1ll                   torn    studio  hill
    facedBANGINGf33d1ngneutral       faced   banging feeding neutral
    azureNEALb41t1ngtarnishCINDER    azure   neal    baiting tarnish cinder

I use these passwords for signing up on various websites, and want to balance
the ease of remembering these passwords against their worst-case crackability.

I've taken the words lists from two different sources:

    1) The New General Service List (NSGL)
       http://www.newgeneralservicelist.org
       Creative Commons Attribution 3.0 Unported License
    2) Wiktionary.org's Project Gutenberg frequency lists. 
       https://en.wiktionary.org/wiki/Wiktionary:Frequency_lists#Project_Gutenberg
       Creative Commons Attribution-ShareAlike License

This is security through obscurity, as if an attacker knows the template and
the wordlists, then they can easily craft a password cracker to suit.

Three-word passwords at least have a length of 12 characters or more, and won't
fall to the simplest dictionary attacks.

Don't use passphrases generated by the default settings for anything important,
as there just isn't enough entropy to be safe.

With the default settings, there are about 2.16e11 possible passphrases
(ignoring the differences in case and l33t-ness). Modern password crackers can
test billions of password hashes per second, so could find a match in a couple
of minutes if the wordlists and algorithm are known.

Running with more and longer words does give you more entropy and safety.  The
following run has about 1.66e20 possible passphrases, 750 million times as many
as the default case. This should take about 750 million times as long to crack.

    $ passgen --words 5 --min 4 --max 8

For comparison, a random 8-character password made up of 93 characters you can
easily enter from the keyboard has 5.60e15 possibilities, so has far higher
entropy than the default passphrases generated with B<--words 3 --min 4 --max
6>, and far lower entropy than generated with B<--words 5 --min 4 --max 8>.

=head1 CAVEAT

This script hasn't been audited by anyone who knows anything about password
security.

=cut

use Crypt::Random ();
use Getopt::Long;
use List::MoreUtils ();
use Pod::Usage;

my $num_words       = 3;
my $min_word_len    = 4;
my $max_word_len    = 6;
my $num_passphrases = 10;

GetOptions(
    'words=i' => \$num_words,
    'min=i'   => \$min_word_len,
    'max=i'   => \$max_word_len,
    'gen=i'   => \$num_passphrases,
    'help|?'  => sub { pod2usage() },
) or pod2usage();

my $wordlist = get_wordlist();

for ( 1 .. $num_passphrases ) {
    my $words      = pick_words( $wordlist, $num_words );
    my $max_len    = $num_words * $max_word_len;
    my $format_str = "%-${max_len}s " . "\%-${max_word_len}s " x @$words;
    printf "$format_str\n", format_phrase($words), @$words;
}

exit;

#
# Format a passphrase to the following spec.
#
# The first word will be lowercase.
# The second word will be UPPERCASE
# The third word will be tr/aeio/4310/
# Subsequent words follow the pattern starting from step 1 again.
#
sub format_phrase {
    my $words = shift;

    my $phrase = '';
    for (my $index = 0; $index < scalar @$words; $index ++) {
        my $word = $words->[$index];
        if ( $index % 3 == 0 ) {
            $phrase .= $word;
        }
        elsif ( $index % 3 == 1 ) {
            $phrase .= uc $word;
        }
        else {
            $word =~ tr{aeio}{4310};
            $phrase .= $word;
        }
    }

    return $phrase;
}

#
# Pick N words from wordlist without replacement.
#
sub pick_words {
    my $wordlist = shift;
    my $n        = shift;

    my $num_words = scalar @$wordlist;
    my %seen_words;
    my @words;
    while ( scalar @words < $n ) {
        my $index = Crypt::Random::makerandom_itv(
            Strength => 0,                 # Always use /dev/urandom, so it doesn't block.
            Uniform  => 1,                 # Uniformly distributed.
            Lower    => 1,                 # Lower bound.
            Upper    => $num_words - 1,    # Upper bound.
        );
        next if $seen_words{$index};

        # Every third word needs to contain at least one of the first four
        # vowels for the a->4, e->3, i->1, o->0 transform.
        if ( scalar @words % 3 == 2 ) {
            next unless $wordlist->[$index] =~ m{ [aeio] }xms;
        }

        push @words, $wordlist->[$index];
        $seen_words{$index} = 1;
    }

    return \@words;
}

#
# Read in a dictionary file or files from disk, and filter for length and a few
# other things.
#
# die() unless enough words are found.
#
sub get_wordlist {
    my @dict_files = qw(
        ngsl.txt
        wiktionary_words_1-10k.txt
        wiktionary_words_10k-20k.txt
    );

    my @wordlist;
    for my $file ( @dict_files ) {
        next unless -f $file;

        open my $fh, '<', $file
            or die "FATAL: Unable to open '$file' for reading - $!";

        WORD: while ( my $word = <$fh> ) {
            chomp $word;

            # Remove any # comment
            $word =~ s{ \s* \# .*}{}xms;
            next WORD unless $word;

            # Filter for length.
            next WORD if length $word < $min_word_len || length $word > $max_word_len;

            # Filter out plurals (and any words actually ending in s).
            next WORD if substr($word, -1) eq 's'; 

            push @wordlist, lc $word;
        }

        close $fh;
    }

    @wordlist = List::MoreUtils::uniq @wordlist;

    die "FATAL: get_wordlist() unable to load enough words from "
      . join( ', ', @dict_files )
      . ". Found only "
      . scalar @wordlist
        unless @wordlist > 4000;

    print "FOUND: " . scalar @wordlist . " words\n";
    return \@wordlist;
}

__END__

=head1 LICENCE

Copyright 2016 Dave Webb

passgen is free software. You can do B<anything> you like with it.

=cut
