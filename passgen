#!/usr/bin/perl

use strict;
use warnings;

=head1 NAME

passgen - generate secure-ish passwords

=head1 SYNOPSIS

    passgen [num words]

    Examples:

        # Default three-word passphrase.
        $ passgen

        # Stronger five-word passphrase.
        $ passgen 5

=head1 DESCRIPTION

This perl script generates passwords/passphrases from my chosen template. This
template is for three or more short words to be concatenated together. The
first word is all lowercase, the second word is ALL UPPERCASE, and the third
word uses the standard 'replace vowels with numbers' leetspeek transform. Any
further words continue the pattern starting at step 1 again.

For example:

    hairedBROACHn33d1ng              haired  broach  needing
    tornSTUDIOh1ll                   torn    studio  hill
    facedBANGINGf33d1ngneutral       faced   banging feeding neutral
    azureNEALb41t1ngtarnishCINDER    azure   neal    baiting tarnish cinder

I use these passwords for signing up on various websites, and want to balance
the ease of remembering these passwords against their worst-case crackability.

I've taken the words lists from two different sources:

    1) The New General Service List (NSGL)
       http://www.newgeneralservicelist.org
       Creative Commons Attribution 3.0 Unported License
    2) Wiktionary.org's Project Gutenberg frequency lists. 
       https://en.wiktionary.org/wiki/Wiktionary:Frequency_lists#Project_Gutenberg
       Creative Commons Attribution-ShareAlike License

This is security through obscurity, as if an attacker knows the template and
the wordlists, then they can easily craft a password cracker to suit.

Three-word passwords at least have a length of 12 characters or more, and won't
fall to the simplest dictionary attacks.

Don't use these passwords for anything important, however, as there just isn't
enough entropy to be safe.

For example, with the 8544 common english words used here, the number of
passphrases is 8544 * 8544 * 8544, or 623,711,453,184. This appears a pretty
large number, but modern password crackers can test billions of passwords per
second, so less than ten minutes on average if the wordlists and algorithm are
known.

Even a random 8-character password made up of those characters you can easily
enter from the keyboard has larger entropy. My keyboard allows me to easily
enter a-zA-Z0-9 plus the punctuation and other special characters:
!@Â£$%^&*()_+-={}[ ]:"|;'\<>?,./ This comes to 93 different characters, and 93^8
(2,252,292,232,139,041) combinations, which is 9000 times as large as the number
from the three dictionary words above, so should take 9000 times longer to
crack.

This script hasn't been audited by anyone who knows anything about password
security.

=head1 TODO

=over

=item * Have min/max word length and vowel numbers as commandline args.

=back

=cut

use Crypt::Random ();
use List::MoreUtils ();

my $num_words    = shift || 3;
my $min_word_len = 4;
my $max_word_len = 6;
my $wordlist     = get_wordlist();

for ( 1 .. 20 ) {
    my $words      = pick_words( $wordlist, $num_words );
    my $max_len    = $num_words * $max_word_len;
    my $format_str = "%-${max_len}s " . "\%-${max_word_len}s " x @$words;
    printf "$format_str\n", format_phrase($words), @$words;
}

exit;

#
# Format a passphrase to the following spec.
#
# The first word will be lowercase.
# The second word will be UPPERCASE
# The third word will be tr/aeio/4310/
# Subsequent words follow the pattern starting from step 1 again.
#
sub format_phrase {
    my $words = shift;

    my $phrase = '';
    for (my $index = 0; $index < scalar @$words; $index ++) {
        my $word = $words->[$index];
        if ( $index % 3 == 0 ) {
            $phrase .= $word;
        }
        elsif ( $index % 3 == 1 ) {
            $phrase .= uc $word;
        }
        else {
            $word =~ tr{aeio}{4310};
            $phrase .= $word;
        }
    }

    return $phrase;
}

#
# Pick N words from wordlist without replacement.
#
sub pick_words {
    my $wordlist = shift;
    my $n        = shift;

    my $num_words = scalar @$wordlist;
    my %seen_words;
    my @words;
    while ( scalar @words < $n ) {
        my $index = Crypt::Random::makerandom_itv(
            Strength => 0,                 # Always use /dev/urandom, so it doesn't block.
            Uniform  => 1,                 # Uniformly distributed.
            Lower    => 1,                 # Lower bound.
            Upper    => $num_words - 1,    # Upper bound.
        );
        next if $seen_words{$index};
        push @words, $wordlist->[$index];
        $seen_words{$index} = 1;
    }

    return \@words;
}

#
# Read in a dictionary file or files from disk, and filter for length and a few
# other things.
#
# die() unless enough words are found.
#
sub get_wordlist {
    my @dict_files = qw(
        ngsl.txt
        wiktionary_words_1-10k.txt
        wiktionary_words_10k-20k.txt
    );

    my @wordlist;
    for my $file ( @dict_files ) {
        next unless -f $file;

        open my $fh, '<', $file
            or die "FATAL: Unable to open '$file' for reading - $!";

        WORD: while ( my $word = <$fh> ) {
            chomp $word;

            # Remove any # comment
            $word =~ s{ \s* \# .*}{}xms;
            next WORD unless $word;

            # Filter for length.
            next WORD if length $word < $min_word_len || length $word > $max_word_len;

            # Filter out plurals (and any words actually ending in s).
            next WORD if substr($word, -1) eq 's'; 

            # Word must contain at least one of first 4 vowels.
            next WORD unless $word =~ m{ [aeio] }xms;
            push @wordlist, lc $word;
        }

        close $fh;
    }

    die "FATAL: get_wordlist() unable to load enough words from "
      . join( ', ', @dict_files )
      . ". Found only "
      . scalar @wordlist
        unless @wordlist > 4000;

    @wordlist = List::MoreUtils::uniq @wordlist;
    print "FOUND: " . scalar @wordlist . " words\n";
    return \@wordlist;
}

__END__

=head1 LICENCE

Copyright 2015 Dave Webb

passgen is free software. You can do B<anything> you like with it.

=cut
