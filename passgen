#!/usr/bin/perl

use strict;
use warnings;

=head1 NAME

passgen - generate secure-ish passwords

=head1 DESCRIPTION

This perl script generates passwords/passphrases from my chosen template. This
template is for three short words to be concatenated together. The first word
is all lowercase, the second word is ALL UPPERCASE, and the third word uses the
standard 'replace vowels with numbers' leetspeek transform.

For example:

This is security through obscurity, as if an attacker knows the template, then
they can easily craft a password cracker to suit.

I use these passwords for signing up on various websites, and want to balance
the ease of remembering these passwords against their worst-case crackability.

Three-word passwords at least have a length of 12 characters or more, and won't
fall to the simplest dictionary attacks.

Don't use these passwords for anything important.

This script hasn't been audited by anyone who knows anything about password
security.

=head1 TODO

=over

=item * Make sure @wordlist contains no dups.

=back

=cut

use Crypt::Random ();

my $wordlist = get_wordlist();

for (1..20) {
    my $words = pick_words($wordlist, 3);
    print format_phrase($words) . " " . join(' ', @$words) . "\n";
}

exit;

#
# Format a passphrase to the following spec.
#
# The first word will be lowercase.
# The second word will be UPPERCASE
# The third word will be tr/aeio/4310/
# Subsequent words follow the pattern starting from step 1 again.
#
sub format_phrase {
    my $words = shift;

    my $phrase = '';
    for (my $index = 0; $index < scalar @$words; $index ++) {
        my $word = $words->[$index];
        if ( $index % 3 == 0 ) {
            $phrase .= $word;
        }
        elsif ( $index % 3 == 1 ) {
            $phrase .= uc $word;
        }
        else {
            $word =~ tr{aeio}{4310};
            $phrase .= $word;
        }
    }

    return $phrase;
}

#
# Pick N words from wordlist without replacement.
#
sub pick_words {
    my $wordlist = shift;
    my $n        = shift;

    my $num_words = scalar @$wordlist;
    my %seen_words;
    my @words;
    while ( scalar @words < $n ) {
        my $index = Crypt::Random::makerandom_itv(
            Strength => 0,                 # Always use /dev/urandom, so it doesn't block.
            Uniform  => 1,                 # Uniformly distributed.
            Lower    => 1,                 # Lower bound.
            Upper    => $num_words - 1,    # Upper bound.
        );
        next if $seen_words{$index};
        push @words, $wordlist->[$index];
        $seen_words{$index} = 1;
    }

    return \@words;
}

#
# Read in a dictionary file from disk, and filter for length and a few other
# things.
# die() unless enough words are found.
#
sub get_wordlist {
    my @dict_files = qw(/usr/share/dict/words);

    my @wordlist;
    for my $file ( @dict_files ) {
        next unless -f $file;
        
        open my $fh, '<', $file
            or die "FATAL: Unable to open '$file' for reading - $!";

        WORD: while ( my $word = <$fh> ) {
            chomp $word;

            # Filter for length.
            next WORD if length $word < 5 || length $word > 9;

            # Filter out plurals (and any words actually ending in s).
            next WORD if substr($word, -1) eq 's'; 

            # Word must contain two of first 4 vowels.
            next WORD unless $word =~ m{ [aeio] .* [aeio] }xms;
            push @wordlist, lc $word;
        }

        close $fh;
    }

    die "FATAL: get_wordlist() unable to load enough words from " . join( ', ', @dict_files ) . ". Found only " . scalar @wordlist
        unless @wordlist > 20_000;

    print "FOUND: " . scalar @wordlist . " words\n";
    return \@wordlist;
}

__END__


